var documenterSearchIndex = {"docs":
[{"location":"#FourierTools.jl","page":"FourierTools.jl","title":"FourierTools.jl","text":"","category":"section"},{"location":"","page":"FourierTools.jl","title":"FourierTools.jl","text":"Here you can find the docstrings of all functions.","category":"page"},{"location":"#FFT-based-resampling","page":"FourierTools.jl","title":"FFT based resampling","text":"","category":"section"},{"location":"","page":"FourierTools.jl","title":"FourierTools.jl","text":"This allows to sinc interpolate a signal. The resulting size can be larger or smaller.","category":"page"},{"location":"","page":"FourierTools.jl","title":"FourierTools.jl","text":"resample","category":"page"},{"location":"#FourierTools.resample","page":"FourierTools.jl","title":"FourierTools.resample","text":"resample(arr, new_size [, normalize])\n\nCalculates the sinc interpolation of an arr on a new array size new_size. It is a re-evaluation of the Fourier series at new grid points. new_size can be arbitrary. Each dimension is then independently either up or downsampled. This method is based on FFTs and therefore implicitly assumes periodic boundaries and a finite frequency support. normalize=true by default multiplies by an appropriate factor so that  the average intensity stays the same. If size(new_size)[i] > size(arr)[i], we apply zero padding in Fourier space. If size(new_size)[i] < size(arr)[i], we cut out a centered part of the Fourier spectrum. We apply some tricks at the boundary to increase accuracy of highest frequencies.  ```\n\n\n\n\n\n","category":"function"},{"location":"#FFT-helpers","page":"FourierTools.jl","title":"FFT helpers","text":"","category":"section"},{"location":"","page":"FourierTools.jl","title":"FourierTools.jl","text":"ft\nift\nrft\nirft\nFourierTools.fftshift_view\nFourierTools.ifftshift_view","category":"page"},{"location":"#FourierTools.ft","page":"FourierTools.jl","title":"FourierTools.ft","text":"ft(A [, dims])\n\nResult is semantically equivalent to fftshift(fft(ifftshift(A, dims), dims), dims) However, the shift is done with ShiftedArrays and therefore doesn't allocate memory.\n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.ift","page":"FourierTools.jl","title":"FourierTools.ift","text":"ift(A [, dims])\n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.rft","page":"FourierTools.jl","title":"FourierTools.rft","text":"rft(A [, dims])\n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.irft","page":"FourierTools.jl","title":"FourierTools.irft","text":"irft(A, d, [, dims])\n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.fftshift_view","page":"FourierTools.jl","title":"FourierTools.fftshift_view","text":"fftshift_view(A [, dims])\n\nResult is semantically equivalent to fftshift(A, dims) but returns  a view instead. \n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.ifftshift_view","page":"FourierTools.jl","title":"FourierTools.ifftshift_view","text":"ifftshift_view(A [, dims])\n\nResult is semantically equivalent to fftshift(A, dims) but returns  a view instead. \n\n\n\n\n\n","category":"function"}]
}
