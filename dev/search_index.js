var documenterSearchIndex = {"docs":
[{"location":"fractional/#Fractional-Fourier-Transforms","page":"Fractional Fourier Transform","title":"Fractional Fourier Transforms","text":"Implementation of the Fast Fractional Fourier Transform based on Javier García, David Mas, and Rainer G. Dorsch, \"Fractional-Fourier-transform calculation through the fast-Fourier-transform algorithm,\" Appl. Opt. 35, 7013-7018 (1996)","category":"section"},{"location":"fractional/#FourierTools.frfft","page":"Fractional Fourier Transform","title":"FourierTools.frfft","text":"frfft(arr, p; shift=false, method=:garcia)\n\nCalculates the fractional Fast Fourier transform (FRFFT) of the order p of arr. No dims argument is supported yet.\n\nIf shift=false the FRFFT is calculated around the first entry. If shift=true the FRFFT is calculated aroound the center.\n\nMethods\n\nSeveral implementation exists. The following are implemented: \n\nmethod=:garcia: A convolutional approach based on 2 FFTs. See García, J., Mas, D., & Dorsch, R. G. (1996). Fractional-Fourier-transform calculation through the fast-Fourier-transform algorithm. Applied Optics, 35(35), 7013. doi:10.1364/ao.35.007013 \n\n\n\n\n\n","category":"function"},{"location":"rotate/#Rotation-with-FFT","page":"Image Rotation with FFTs","title":"Rotation with FFT","text":"Via shear it is possible to rotate an image. Since we also implemented a shear algorithm, rotation can be implemented as well. For details look at this webpage.","category":"section"},{"location":"rotate/#Examples","page":"Image Rotation with FFTs","title":"Examples","text":"For full interactivity, have a look at this Pluto notebook.\n\nusing Revise, FourierTools, Plots, TestImages, PlutoUI, ImageShow\n\nbegin\n    img = Float32.(testimage(\"fabio_512_gray\"))\n    z = zeros(Float32, (768, 768))\n    FourierTools.center_set!(z, img)\nend\n\n\nGray.(FourierTools.rotate(z, 26))\n\n(Image: )","category":"section"},{"location":"rotate/#Function-references","page":"Image Rotation with FFTs","title":"Function references","text":"","category":"section"},{"location":"rotate/#FourierTools.rotate","page":"Image Rotation with FFTs","title":"FourierTools.rotate","text":"rotate(arr, θ, rotation_plane=(1,2), adapt_size=true, keep_new_size=false)\n\nRotate an arr in the plane rotation_plane with an angle θ in rad around the center pixel. Note that, in contrast to ImageTransformations.imrotate, the rotation is done around the Fourier-center pixel (size()÷2+1) and not the geometric  mid point.\n\nArguments:\n\narr: the array to rotate\nΘ: the angle (in rad) to rotate by\nrotation_plane: two dimensions selecting the 2D plane in which a multidimensional dataset is rotated \nadapt_size: if true (default), the three shears, which make up the rotation, will be allowed to enlarge the size of the array. This is slower but avoids wrap-around artefacts   If false, the in-place version of rotate is used with all its problems. Only recommended for very small angles!\nkeep_new_size: if true, the enlarged sizes (only for adapt_size=true) will also be returned. Otherwise the resulting data will be cut down to the original size\npad_value: specifies the value that areas outside the visible range (in the source) should be assigend to. A smart choice can reduce edge artefacts.\n\nrotate! is also available.\n\n\n\n\n\n","category":"function"},{"location":"rotate/#FourierTools.rotate!","page":"Image Rotation with FFTs","title":"FourierTools.rotate!","text":"rotate!(arr, θ, rotation_plane=(1,2))\n\nIn-place rotate an arr in the plane spanned by the two dimensions in the tuple rotation_plane with an angle θ in rad around the center pixel. Note that, in contrast to ImageTransformations.imrotate, the rotation is done around the Fourier-center pixel (size()÷2+1) and not the geometric  mid point. Note also that due to the operation being performed by successive cyclic shear operations in-place, pixels near the corner will be experiencing a massive wrap-around problem. Use the out-of-place version rotate to avoid this. Note also that this version generates very bad results with the angle approaching π. To fix this, use the out-of-place version of rotate.\n\nArguments:\n\narr: the array to rotate\nΘ: the angle (in rad) to rotate by\nrotation_plane: two dimensions selecting the 2D plane in which a multidimensional dataset is rotated \n\n\n\n\n\n","category":"function"},{"location":"shear/#Rotation-with-FFT","page":"Image Shearing with FFTs","title":"Rotation with FFT","text":"Via shear it is possible to rotate an image. Shearing is basically a shift operation but with different shift distance in each row.","category":"section"},{"location":"shear/#Examples","page":"Image Shearing with FFTs","title":"Examples","text":"For full interactivity, have a look at this Pluto notebook.\n\nusing Revise, FourierTools, Plots, TestImages, PlutoUI, ImageShow\n\nbegin\n    img = Float32.(testimage(\"fabio_512_gray\"))\n    z = zeros(Float32, (768, 768))\n    FourierTools.center_set!(z, img)\nend\n\nGray.(FourierTools.shear(z, -305))\n\n(Image: )","category":"section"},{"location":"shear/#Function-references","page":"Image Shearing with FFTs","title":"Function references","text":"","category":"section"},{"location":"shear/#FourierTools.shear","page":"Image Shearing with FFTs","title":"FourierTools.shear","text":"shear(arr, Δ, shear_dir_dim=1, shear_dim=2; fix_nyquist=false, adapt_size=false::Bool, pad_value=zero(eltype(arr)))\n\nShears an array by the amount of Δ pixels via an FFT approach. Δ is the relative shift between the top and bottom row shifted with respect to each other. shear_dir_dim decides the direction of the shear and shear_dim is the  second dimension where the shear happens. There is also shear! available.\n\n#Arguments\n\narr: array to shear \nshear_dir_dim: dimension of the shift during shear\nshear_dim: dimension along which to progress and apply variing shears along shear_dir_dim\nfix_nyquist: apply a fix to the highest frequency during the Fourier-space application of the exponential factor\nadapt_size: if true, pad the data prior to the shear. The result array will be larger\npad_value: the value to pad with (only applies if adapt_size=true)\nassign_wrap=assign_wrap: replaces wrap-around areas by pad_value (only of adapt_size is false)\n\nFor complex arrays we use fft, for real array we use rfft.\n\n\n\n\n\n","category":"function"},{"location":"shear/#FourierTools.shear!","page":"Image Shearing with FFTs","title":"FourierTools.shear!","text":"shear!(arr, Δ, shear_dir_dim=1, shear_dim=2; fix_nyquist=false, assign_wrap=false, pad_value=zero(eltype(arr)))\n\nFor more details see shear.\n\nExtra Arguments\n\nassign_wrap: if true wrap-around areas are replaced by pad_value pad_value:   the value to replace wrap-around areas with\n\nFor complex arrays we can completely avoid large memory allocations. For real arrays, we need at least allocate on array in the fourier space.\n\n\n\n\n\n","category":"function"},{"location":"resampling/#Resampling","page":"Resampling (sinc Interpolation)","title":"Resampling","text":"To sinc interpolate a signal, it is possible to zero pad a signal in Fourier space and to do an inverse Fourier transform effectively evaluating the Fourier series at more samples. If the signal was initially band-limited, sinc interpolation leads to smoother, perfectly interpolated signals","category":"section"},{"location":"resampling/#Sinc-interpolation","page":"Resampling (sinc Interpolation)","title":"Sinc interpolation","text":"Below you can find a simple example for up sampling using resample.  Furthermore, there is an image interpolation Pluto.jl notebook in the examples folder. We can see that the interpolated signal matches the higher sampled signal well.\n\n begin\n\tN_low = 128\n\tx_min = 0.0\n\tx_max = 16π\n\t\n\txs_low = range(x_min, x_max, length=N_low+1)[1:N_low]\n\txs_high = range(x_min, x_max, length=5000)[1:end-1]\n\tf(x) = sin(0.5*x) + cos(x) + cos(2 * x) + sin(0.25*x)\n\tarr_low = f.(xs_low)\n\tarr_high = f.(xs_high)\nend\n\nbegin\n\tN = 1000\n\txs_interp = range(x_min, x_max, length=N+1)[1:N]\n\tarr_interp = resample(arr_low, N)\nend\n\nbegin\n\tscatter(xs_low, arr_low, legend=:bottomleft, markersize=2, label=\"Low sampling\")\n\tplot!(xs_interp, arr_interp, label=\"FFT based sinc interpolation\", linestyle=:dash)\n\tplot!(xs_high, arr_high, linestyle=:dashdotdot, label=\"High sampling\")\nend\n\n(Image: )","category":"section"},{"location":"resampling/#Downsampling","page":"Resampling (sinc Interpolation)","title":"Downsampling","text":"32 samples in the downsampled signal should be sufficient for Nyquist sampling. And as we can see, the downsampled signal still matches the original one.\n\nbegin\n\tN_ds = 32\n\txs_ds = range(x_min, x_max, length=N_ds+1)[1:N_ds]\n\tarr_ds = resample(arr_high, N_ds)\nend\n\nbegin\n\tscatter(xs_low, arr_low, legend=:bottomleft, markersize=2, label=\"Low sampling\")\n\tplot!(xs_interp, arr_interp, label=\"FFT based sinc interpolation\", linestyle=:dash)\n\tplot!(xs_ds, arr_ds, label=\"resampled array\", linestyle=:dot)\t\nend\n\n(Image: )","category":"section"},{"location":"resampling/#Image-Upsampling","page":"Resampling (sinc Interpolation)","title":"Image Upsampling","text":"Having a Nyquist sampled image, it is possible to perform a sinc interpolation and creating visually much nicer images. However, the information content does not change between both images. The full Pluto notebook is here. The right image is the upsampled version of the left one.\n\n(Image: ) (Image: )\n\nThere are fast versions (upsample2) for upsampling by a factor of 2.","category":"section"},{"location":"resampling/#Function-References","page":"Resampling (sinc Interpolation)","title":"Function References","text":"","category":"section"},{"location":"resampling/#FourierTools.resample","page":"Resampling (sinc Interpolation)","title":"FourierTools.resample","text":"resample(arr, new_size [, normalize=true])\n\nCalculates the sinc interpolation of an arr on a new array size new_size. It is a re-evaluation of the Fourier series at new grid points. new_size can be arbitrary. Each dimension is then independently either up or downsampled.\n\nThis method is based on FFTs and therefore implicitly assumes periodic boundaries and a finite frequency support.\n\nnormalize=true by default multiplies by an appropriate factor so that the array size is included in the scaling. This results in an array having roughly the same mean intensity.\n\nBasic Principle\n\nIf size(new_size)[i] > size(arr)[i], we apply zero padding in Fourier space.\n\nIf size(new_size)[i] < size(arr)[i], we cut out a centered part of the Fourier spectrum.\n\nWe apply some tricks at the boundary to increase accuracy of highest frequencies. \n\nFor real arrays we use rfft based operations, for complex one we use fft based ones.\n\nExamples\n\nsinc interpolation of 2 datapoints result in an approximation of cosine.\n\njulia> resample([2.0, 0.0], (6,))\n6-element Vector{Float64}:\n 2.0\n 1.5\n 0.5\n 0.0\n 0.5\n 1.5\n\njulia> resample([2.0, 0.0], (6,)) ≈ 1 .+ cos.(2π .* (0:5)./6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.resample_by_FFT","page":"Resampling (sinc Interpolation)","title":"FourierTools.resample_by_FFT","text":"resample_by_FFT(mat, new_size)\n\nDoes a resampling based on fft. This function is called by resampling.\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.resample_by_RFFT","page":"Resampling (sinc Interpolation)","title":"FourierTools.resample_by_RFFT","text":"resample_by_RFFT(mat, new_size)\n\nDoes a resampling based on rfft. This function is called by resampling.\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.resample_nfft","page":"Resampling (sinc Interpolation)","title":"FourierTools.resample_nfft","text":"resample_nfft(img, new_pos, dst_size=nothing; pixel_coords=false, is_local_shift=false, is_src_coords=true, reltol=1e-9)\n\nresamples an ND-array to a set of new positions new_pos measured in either in pixels (pixel_coords=true)  or relative (Fourier-) image coordinates (pixel_coords=false). new_pos can be \n\nan array of Tuples specifying the zoom along each direction\nan N+1 dimensional array (for N-dimensional input data img) of destination positions, the last dimension  enumerating the respective destination coordinate dimension.\na function accepting a coordinate Tuple and yielding a destination position Tuple.\n\nresample_nfft can perform a large range of possible resamplings. Note that the default setting is is_src_coords=true  which means that the source coordinates of each destination position have to be specified. This has the advantage that  the result has usually less artefacts, but the positions may be more less convenient to specify.\n\nArguments\n\nimg: the image to apply resampling to\nnew_pos`: specifies the resampling. See description above.\ndst_size: this argument optionally defines the output size. If you require a different result size              for new_pos being a function or with is_src_coords=true, state it here. By default (dst_size=nothing) the              destination size will be inferred form the argument new_pos or assumed to be size(img).\nis_local_shift: specifies, whether the resampling coordinates refer to a relative shift or absoluter coordinates\nis_in_pixels: specifies whether the coordinates (or relative distances) are given in pixel pitch units (is_in_pixels=true) or in units relative to the array sizes (Fourier convention) \nis_src_coords: specifies, whether the resampling positions refer to sampling at source (is_src_coords=true) or destination coordinates \nreltol: will be used as an argument to the nfft function spedifying the relative precision to calculate to\n\nSee also: resample, resample_czt\n\nExamples\n\njulia> using FourierTools, TestImages, NDTools, View5D, IndexFunArrays\n\njulia> a = Float32.(testimage(\"resolution\"));\n\njulia> b = resample_nfft(a, t -> (2.5f0 *sign(t[1])*t[1]^2, t[2]*(0.5f0+t[1]))); # a complicated deformation\n\njulia> sz = size(a);\n\n# stacking only the displacement along the last dimension:\njulia> new_pos = cat(xx(sz,scale=ScaFT), zeros(sz), dims=3);\n\njulia> c = resample_nfft(a, new_pos, is_local_shift=true); # stretch along x using an array\n\njulia> new_pos = cat(.-xx(sz,scale=ScaFT)./2, zeros(sz), dims=3);\n\njulia> c2 = resample_nfft(a, new_pos, is_local_shift=true, is_src_coords=false); # stretch along x using an array\n\n# Notice the difference in brightness between c and c2\njulia> @ve a b c c2 # visualize distortion and x-shrinks. \n\n# Lets try a 2D rotation:\n# define a rotation operation\njulia> rot_alpha(a, t) = (cosd(a)*t[1] + sind(a)*t[2], -sind(a)*t[1]+cosd(a)*t[2])\n\n# positions as an array of tuples\njulia> new_pos = rot_alpha.(10.0, idx(a, scale=ScaFT))\n\n# lets do the resampling, this time by specifying the destination coordinates:\njulia> d = resample_nfft(a, new_pos, is_src_coords=false);\n\n#display the result\njulia> @ve a d\n\n#how about a spiral deformation?\njulia> new_pos = rot_alpha.(rr(a), idx(a, scale=ScaFT))\n\njulia> e = resample_nfft(a, new_pos);\n\njulia> f = resample_nfft(a, new_pos, is_src_coords=false);\n\n# observe the artefacts generated by undersampling in the destination grid\njulia> @ve a e f\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.resample_czt","page":"Resampling (sinc Interpolation)","title":"FourierTools.resample_czt","text":"resample_czt(arr, rel_zoom; shear=nothing, shear_dim=nothing, fix_nyquist=false, new_size = size(arr), \n             do_damp=false, rel_pad=0.2, remove_wrap=true)\n\nresamples the image with fixed factors or a list of separable functions using the chirp z transform algorithm. The data is first padded by a relative amount rel_pad which is needed to avoid wrap-around problems. As opposed to resample(), this routine allows for arbitrary non-integer zoom factors. It is reasonably fast but only allows a stretch (via rel_zoom) and a shift (via shear in pixels) per line or column.\n\nNote that each entry of the tuple in rel_zoom or shear describes the zoom or shear to apply to all other dimensions individually per entry along this dimension number. \n\nArguments:\n\narr: array to resample\nrel_zoom: factors to zoom as a tuple or a tuple of functions defining the zooms\nshear: a tuple of shears or a tuple of shear functions defining the shears\nshear_dim: which dimension to shear\nfix_nyquist: defines whether to apply fix_nyquist when using the applyshiftstrength! function.\ndo_damp: applies a padding and damping outside the region  to zoom, to avoid artefacts\nrel_pad: amount of padding to apply, if do_damp is true\nremove_wrap: removes the wrap-around when zooming out.\nnew_size: size of the result array. If not provided the same as the input size will be used.\n\nExamples\n\njulia> using TestImages, NDTools, View5D\n\njulia> a = Float32.(testimage(\"resolution\"));\n\njulia> b = resample_czt(a, (0.99,1.3)); # just zooming and shrinking\n\njulia> c = resample_czt(a, (x->0.8+x^2/3,x->1.0+0.2*x)); # a more complicated distortion\n\njulia> d = resample_czt(a, (x->1.0,x->1.0), shear=(x->50*x^2,0.0)); # a more complicated distortion\n\njulia> @ve a,b,c,d # visualize distortions\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.upsample2","page":"Resampling (sinc Interpolation)","title":"FourierTools.upsample2","text":"upsample2(mat::AbstractArray{T, N}; dims=1:N, fix_center=false, keep_singleton=false)\n\nUpsamples by a factor of two in all dimensions.  The code is optimized for speed by using subpixelshifts rather than Fourier resizing. By default the first pixel maintains its position. However, this leads to a shift of the center (size[d]÷2+1) in the resulting array for  uneven array sizes. fix_center=true can be used to remedy this and the result array center position will agree to the source array center position. keep_singleton=true will not upsample dimensions of size one. Note that upsample2 is based on Fourier-shifting and you may have to deal with wrap-around problems.\n\njulia> upsample2(collect(collect(1.0:9.0)'))\n2×18 Matrix{Float64}:\n 1.0  0.24123  2.0  3.24123  3.0  2.93582  4.0  5.0  5.0  5.0  6.0  7.06418  7.0  6.75877  8.0  9.75877  9.0  5.0\n 1.0  0.24123  2.0  3.24123  3.0  2.93582  4.0  5.0  5.0  5.0  6.0  7.06418  7.0  6.75877  8.0  9.75877  9.0  5.0\n\njulia> upsample2(collect(collect(1.0:9.0)'); fix_center=true, keep_singleton=true)\n1×18 Matrix{Float64}:\n 5.0  1.0  0.24123  2.0  3.24123  3.0  2.93582  4.0  5.0  5.0  5.0  6.0  7.06418  7.0  6.75877  8.0  9.75877  9.0\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.upsample2_abs2","page":"Resampling (sinc Interpolation)","title":"FourierTools.upsample2_abs2","text":"upsample2_abs2(mat::AbstractArray{T, N}; dims=1:N)\n\nUpsamples by a factor of two and applies the abs2 operation. The code is optimized for speed.\n\n\n\n\n\n","category":"function"},{"location":"resampling/#FourierTools.barrel_pin","page":"Resampling (sinc Interpolation)","title":"FourierTools.barrel_pin","text":"barrel_pin(arr, rel=0.5)\n\nemulates a barrel (rel>0) or a pincushion (rel<0) distortion. The distortions are calculated  using resample_czt() with separable quadratic zooms.\n\nSee also: resample_czt()\n\nExamples\n\njulia> using TestImages, NDTools, View5D\n\njulia> a = Float32.(testimage(\"resolution\"))\n\njulia> b = barrel_pin(a,0.5) # strong barrel distortion\n\njulia> c = barrel_pin(a,-0.5) # strong pin-cushion distortion\n\njulia> @ve a,b,c # visualize distortions\n\n\n\n\n\n","category":"function"},{"location":"czt/#CZTs","page":"CZT","title":"CZTs","text":"Chirp Z Transformations: Allows Fourier-transformation and at the same time zooming into the result, which is why it is also called the Zoomed-FFT algorithm. The algorithm is loosely based on a publication [Rabiner, Schafer, Rader, The Chirp z-Transform Algorithm, IEEE Trans AU 17(1969) p. 86]. It needs three FFTs to perform its work but one can be precalculated by using plan_czt. Variable zooms, transform dimensions, array center positions as well as output sizes are supported along wiht a low-level interface by specifingy a and w. ","category":"section"},{"location":"czt/#FourierTools.czt","page":"CZT","title":"FourierTools.czt","text":"czt(xin, scale, dims=1:ndims(xin), dsize=size(xin,d); a=nothing, w=nothing, damp=ones(ndims(xin)), \n    src_center=size(xin,d)÷2+1, dst_center=dsize÷2+1, remove_wrap=false, fft_flags=FFTW.ESTIMATE)\n\nChirp z transform of the ND array xin The tuple scale defines the zoom factors in the Fourier domain. Each has to be bigger than one.\n\nSee also: iczt, czt_1d\n\nThe code is based on Rabiner, Schafer & Rader  1969, IEEE Trans. on Audio and Electroacoustics, 17,86-92\n\nArguments:\n\nxin: array to transform\nscale: a tuple of factors (one for each dimension) to zoom into during the czt.   Note that a factor of nothing (or 1.0) needs to be provided, if a dimension is not transformed.\ndims: a tuple of dimensions over which to apply the czt.\ndsize: a tuple specifying the destination size\na: defines the starting phase of the result CZT. This relates to the where the center of the destination       array should be. The default is nothing which means it is calculated from the src_center argument.\nw: defines the consecutive phases of the result array, i.e. the zoom. It is (default nothing)       usually automatically calculated from the scaled and the damp argument.      You only need to state it, if you want to use the low-level interface (e.g. for the Laplace transform).\ndamp: a multiplicative factor to apply as a damping coefficient to w.\nsrc_center: position of the nominal central (zero-position) pixel in the source array. By default the                Fourier-center size(src).÷2 .+1 is used.\ndst_center: the center (zero-position) of the destination array. By default the                Fourier-center size(dst).÷2 .+1 is used.\nremove_wrap: if true, the positions that represent a wrap-around will be set to zero\n\nExample:\n\njulia> using IndexFunArrays\n\njulia> sz = (10,10);\n\njulia> xin = disc(sz,4)\n10×10 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n\njulia> xft = czt(xin,(1.2,1.3));\n\njulia> zoomed = real.(ift(xft))\n10×10 Matrix{Float64}:\n -0.0197423    0.0233008  -0.0449251   0.00295724   0.205593  -0.166546   0.205593   0.00295724  -0.0449251   0.0233008\n  0.0239759   -0.028264    0.0541186  -0.0116475   -0.261294   0.312719  -0.261294  -0.0116475    0.0541186  -0.028264\n -0.0569       0.0666104  -0.122277    0.140354     0.78259    1.34381    0.78259    0.140354    -0.122277    0.0666104\n  0.00540611  -0.0117886   0.0837357   1.30651      1.8283     1.50127    1.8283     1.30651      0.0837357  -0.0117886\n  0.11892     -0.147731    0.368046    1.76537      1.33218    1.66119    1.33218    1.76537      0.368046   -0.147731\n -0.00389861   0.0145979   1.21842     1.52989      1.67375    1.543      1.67375    1.52989      1.21842     0.0145979\n  0.11892     -0.147731    0.368046    1.76537      1.33218    1.66119    1.33218    1.76537      0.368046   -0.147731\n  0.00540611  -0.0117886   0.0837357   1.30651      1.8283     1.50127    1.8283     1.30651      0.0837357  -0.0117886\n -0.0569       0.0666104  -0.122277    0.140354     0.78259    1.34381    0.78259    0.140354    -0.122277    0.0666104\n  0.0239759   -0.028264    0.0541186  -0.0116475   -0.261294   0.312719  -0.261294  -0.0116475    0.0541186  -0.028264\n\n\n\n\n\n","category":"function"},{"location":"czt/#FourierTools.plan_czt","page":"CZT","title":"FourierTools.plan_czt","text":"plan_czt(xin, scale, dims, dsize=size(xin); a=nothing, w=nothing, damp=ones(ndims(xin)), \n         src_center=size(xin).÷2 .+1, dst_center=dsize.÷2 .+1, remove_wrap=false, fft_flags=FFTW.ESTIMATE)\n\ncreates a plan for an N-dimensional chirp z-transformation (CZT). The generated plan is then applied via  muliplication. For details about the arguments, see czt().\n\n\n\n\n\n","category":"function"},{"location":"czt/#FourierTools.iczt","page":"CZT","title":"FourierTools.iczt","text":"iczt(xin ,scale, dims=1:length(size(xin)), dsize=size(xin,d); a=nothing, w=nothing, damp=1.0, \n     src_center=size(xin,d)÷2+1, dst_center=dsize÷2+1, remove_wrap=false, fft_flags=FFTW.ESTIMATE)\n\nInverse chirp z transform of the ND array xin The tuple scale defines the zoom factors in the Fourier domain. Each has to be bigger than one.     The code is based on Rabiner, Schafer & Rader  1969, IEEE Trans. on Audio and Electroacoustics, 17,86-92\n\nArguments:\n\nxin: array to transform\nscaled: factor to zoom into during the 1-dimensional czt. \nd: single dimension to transform (as a tuple)\ndsize: size of the destination array\na: defines the starting phase of the result CZT. This relates to the where the center of the destination       array should be. The default is nothing which means it is calculated from the src_center argument.\nw: defines the consecutive phases of the result array, i.e. the zoom. It is (default nothing) usually       automatically calculated from the scaled and the damp argument.      You only need to state it, if you want to use the low-level interface (e.g. for the Laplace transform).\ndamp: a multiplicative factor to apply as a damping coefficient to w.\nsrc_center: position of the nominal central (zero-position) pixel in the source array. By default the                Fourier-center size(src).÷2 .+1 is used.\ndst_center: the center (zero-position) of the destination array. By default the                Fourier-center size(dst).÷2 .+1 is used.\nremove_wrap: if true, the positions that represent a wrap-around will be set to zero\npad_value: the value to pad wrapped data with. \n\nSee also: czt, czt_1d\n\nExample\n\n\njulia> using IndexFunArrays\n\njulia> sz = (10,10);\n\njulia> xin = disc(sz,4)\n10×10 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n\njulia> xft = ft(xin);\n\njulia> iczt(xft,(1.2,1.3))\n10×10 Matrix{ComplexF64}:\n 0.00648614+0.0213779im  0.0165456+0.0357733im  0.0389356+0.0482465im  -0.235491-0.156509im    …  0.178484-0.0730099im  -0.245418-5.88331e-5im  0.0471654-0.0814548im  0.0141525+0.0734892im\n  -0.104602-0.160481im   -0.163859-0.125535im    0.495205+0.135059im    0.660335+0.00736904im     0.764045-0.0497007im    0.67753+0.263814im      0.48095-0.0775406im  -0.159713-0.0637132im\n   0.139304+0.111348im    0.454973+0.106869im    0.970263-0.0249785im    1.25999-0.166495im        1.07328-0.0481437im    1.24013-0.14664im      0.986722-0.0414382im   0.450186+0.111656im\n  -0.035645-0.0311352im    1.03899-0.0589268im     1.1463-0.0940003im   0.790545+0.283668im       0.994255+0.134865im     0.80774-0.0124851im     1.13205+0.151519im     1.04314-0.130321im\n   0.292575+0.0853233im   0.929883+0.0687029im    1.06514-0.0649952im   0.989483-0.019913im        1.02311+0.018235im    0.979555-0.136654im      1.07337+0.0317868im    0.92749+0.0405597im\n    1.12254-0.0464723im    1.03467-0.0239316im    0.92709+0.0822984im     1.0521-0.0992709im   …  0.983655-0.0663123im     1.0521+0.0992709im     0.92709-0.0822984im    1.03467+0.0239316im\n   0.287928-0.0306724im    0.92749-0.0405597im    1.07337-0.0317868im   0.979555+0.136654im        1.01648+0.0597475im   0.989483+0.019913im      1.06514+0.0649952im   0.929883-0.0687029im\n -0.0275957+0.169775im     1.04314+0.130321im     1.13205-0.151519im     0.80774+0.0124851im       1.00574+0.0629632im   0.790545-0.283668im       1.1463+0.0940003im    1.03899+0.0589268im\n   0.130009-0.120643im    0.450186-0.111656im    0.986722+0.0414382im    1.24013+0.14664im         1.06002+0.0348813im    1.25999+0.166495im     0.970263+0.0249785im   0.454973-0.106869im\n -0.0965531+0.0404296im  -0.159713+0.0637132im    0.48095+0.0775406im    0.67753-0.263814im        0.77553-0.121603im    0.660335-0.00736904im   0.495205-0.135059im   -0.163859+0.125535im\n\n\n\n\n\n","category":"function"},{"location":"czt/#FourierTools.czt_1d","page":"CZT","title":"FourierTools.czt_1d","text":"czt_1d(xin , scaled , d; remove_wrap=false, pad_value=zero(eltype(xin)))\n\nChirp z transform along a single direction d of an ND array xin. Note that the result type is defined by eltype(xin) and not by scales.\n\nThe code is based on Rabiner, Schafer & Rader  1969, IEEE Trans. on Audio and Electroacoustics, 17,86-92\n\nArguments:\n\nxin: array to transform\nscaled: factor to zoom into during the 1-dimensional czt. \nd: single dimension to transform (as a tuple)\ndsize: size of the destination array\na: defines the starting phase of the result CZT. This relates to the where the center of the destination       array should be. The default is nothing which means it is calculated from the src_center argument.\nw: defines the consecutive phases of the result array, i.e. the zoom. It is (default nothing) usually automatically calculated from the scaled and the damp argument.      You only need to state it, if you want to use the low-level interface (e.g. for the Laplace transform).\ndamp: a multiplicative factor to apply as a damping coefficient to w.\nsrc_center: position of the nominal central (zero-position) pixel in the source array. By default the F               ourier-center size(src).÷2 .+1 is used.\ndst_center: the center (zero-position) of the destination array. By default the                Fourier-center size(dst).÷2 .+1 is used.\nextra_phase: a phase ramp to apply to the final result relating to the srccenter. By default nothing which calculates this phase according to the `srccenter`.\nglobal_phase: the initial phase of the destitation array. By default nothing which calculates this phase according to the centers.\nremove_wrap: if true, the positions that represent a wrap-around will be set to zero\npad_value: the value to pad wrapped data with. \n\n\n\n\n\nczt_1d(xin , plan::CZTPlan_1D)\n\nChirp z transform along a single direction d of an ND array xin. Note that the result type is defined by eltype(xin) and not by scales. The plan can also be applied via multiplication with xin.\n\nThe code is based on Rabiner, Schafer & Rader  1969, IEEE Trans. on Audio and Electroacoustics, 17,86-92\n\nArguments\n\n`plan`:   A plan created via plan_czt_1d()\n\n\n\n\n\n","category":"function"},{"location":"czt/#FourierTools.plan_czt_1d","page":"CZT","title":"FourierTools.plan_czt_1d","text":"plan_czt_1d(xin, scaled, d, dsize=size(xin,d); a=nothing, w=nothing, damp=1.0, src_center=(size(xin,d)+1)/2, \n            dst_center=dsize÷2+1, remove_wrap=false, fft_flags=FFTW.ESTIMATE)\n\ncreates a plan for an one-dimensional chirp z-transformation (CZT). The generated plan is then applied via  muliplication. For details about the arguments, see czt_1d().\n\n\n\n\n\n","category":"function"},{"location":"czt/#FourierTools.CZTPlan_1D","page":"CZT","title":"FourierTools.CZTPlan_1D","text":"CZTPlan_1D{CT<:Complex, D<:Integer, AT<:AbstractArray{CT, D}, PT<:Number, PFFT<:AbstractFFTs.Plan, PIFFT<:AbstractFFTs.ScaledPlan}\n\ntype used for the onedimensional plan of the chirp Z transformation (CZT). containing\n\nMembers:\n\n`d`: dimension (only one!) to transform with this plan\n`pad_value`: the value to pad wrapped data with (zero is already handled by the `wd` term, if wanted). \n`pad_ranges` :: tuple of two ranges of invalid positions, which can be replaced by pad values\n`aw`: factor to multiply input with\n`fft_fv`: fourier-transform (FFTW) of the convolutio kernel\n`wd`: factor to multiply the result of the convolution by\n`fftw_plan!`: plan for the forward FFTW of the convolution kernel\n`ifftw_plan!`: plan for the inverse FFTW of the convolution kernel\n\n\n\n\n\n","category":"type"},{"location":"czt/#FourierTools.CZTPlan_ND","page":"CZT","title":"FourierTools.CZTPlan_ND","text":"CZTPlan_ND{CT, D} # <: AbstractArray{T,D}\n\ntype used for the onedimensional plan of the chirp Z transformation (CZT). containing\n\nMembers:\n\n`plans`: vector of CZTPlan_1D for each of the directions of the ND array to transform\n\n\n\n\n\n","category":"type"},{"location":"shifting/#Shifting","page":"Shifting with FFTs","title":"Shifting","text":"Using the Fourier shift property one can implement shifting of arrays not only over pixel but also sub-pixel amount.","category":"section"},{"location":"shifting/#Examples","page":"Shifting with FFTs","title":"Examples","text":"For full interactivity, have a look at this Pluto notebook.\n\nbegin\n    f(x) = cos(4π * x / 30)\n    x1 = 1:30\n    x2 = x1 .+ 3\nend\n\nbegin\n    y1 = f.(x1)\n    y2 = f.(x2)\n    offset = 2.01\n    y3 = shift(y2, tuple(offset))\nend\n\nbegin\n    plot(y1, label=\"Original signal\")\n    plot!(y2, label=\"Shifted signal\")\n    plot!(y3, label=\"Fourier shifted with $offset\")\nend\n\n(Image: )","category":"section"},{"location":"shifting/#Function-references","page":"Shifting with FFTs","title":"Function references","text":"","category":"section"},{"location":"shifting/#FourierTools.shift","page":"Shifting with FFTs","title":"FourierTools.shift","text":"shift(arr, shifts)\n\nReturning a shifted array. See shift! for more details\n\n\n\n\n\n","category":"function"},{"location":"shifting/#FourierTools.shift!","page":"Shifting with FFTs","title":"FourierTools.shift!","text":"shift!(arr, shifts; kwargs...)\n\nShifts an array in-place. For real arrays it is based on rfft. For complex arrays based on fft. shifts can be non-integer, for integer shifts one should prefer circshift or MutableShiftedArrays.circshift because a FFT-based methods introduces numerical errors.\n\nkwargs...\n\nfix_nyquist_frequency=false: Fourier shifting of even-sized arrays is not revertible. However, if you did    shift(x, δ) you can it revert by shift(x, δ, fix_nyquist_frequency=true). This only works if δ is the same.\ntake_real=true: For even-sized arrays we take by default the real part of the exponential phase at the Nyquist frequency.   This satisfies the property of real valuedness and the aliasing of the Nyquist term.\n\nMemory Usage\n\nNote that for complex arrays we can avoid any large memory allocations because of fft!. For rfft there does not exist a usable implementation yet, so for real arrays there might be a temporary larger memory usage.\n\nExamples\n\njulia> x = [1.0 2.0 3.0; 4.0 5.0 6.0]\n2×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n\njulia> shift!(x, (1, 2))\n2×3 Matrix{Float64}:\n 5.0  6.0  4.0\n 2.0  3.0  1.0\n\njulia> x = [0, 1.0, 0.0, 1.0]\n4-element Vector{Float64}:\n 0.0\n 1.0\n 0.0\n 1.0\n\njulia> shift!(x, 0.5)\n4-element Vector{Float64}:\n 0.49999999999999994\n 0.5\n 0.49999999999999994\n 0.5\n\n\n\n\n\n","category":"function"},{"location":"utils/#Some-Utility-Functions","page":"Utility Functions","title":"Some Utility Functions","text":"","category":"section"},{"location":"utils/#FourierTools.δ","page":"Utility Functions","title":"FourierTools.δ","text":"δ([T,] sz, pos=FourierTools.fft_center.(sz))\n\nReturn an array which has 1 at pos in the  array of size sz.\n\nExamples\n\njulia> δ((3, 3))\n3×3 Matrix{Int64}:\n 0  0  0\n 0  1  0\n 0  0  0\n\njulia> δ(Float32, (4, 3))\n4×3 Matrix{Float32}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  0.0\n\njulia> δ(Float32, (3, 3), (1,1))\n3×3 Matrix{Float32}:\n 1.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.center_set!","page":"Utility Functions","title":"FourierTools.center_set!","text":"center_set!(arr_large, arr_small)\n\nPuts the arr_small central into arr_large. The convention, where the center is, is the same as the definition as for FFT based centered. Function works both for even and uneven arrays.\n\nExamples\n\njulia> FourierTools.center_set!([1, 1, 1, 1, 1, 1], [5, 5, 5])\n6-element Array{Int64,1}:\n 1\n 1\n 5\n 5\n 5\n 1\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.get_indices_around_center","page":"Utility Functions","title":"FourierTools.get_indices_around_center","text":"get_indices_around_center(i_in, i_out)\n\nA function which provides two output indices i1 and i2 where i2 - i1 = i_out The indices are chosen such that the set i1:i2 cuts the interval 1:i_in in a way that the center frequency stays at the center position. Works for both odd and even indices\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.center_extract","page":"Utility Functions","title":"FourierTools.center_extract","text":"center_extract(arr, new_size_array)\n\nExtracts a center of an array.  new_size_array must be list of sizes indicating the output size of each dimension. Centered means that a center frequency stays at the center position. Works for even and uneven. If length(new_size_array) < length(ndims(arr)) the remaining dimensions are untouched and copied.\n\nExamples\n\njulia> FourierTools.center_extract([1 2; 3 4], [1])\n1×2 view(::Matrix{Int64}, 2:2, 1:2) with eltype Int64:\n 3  4\n\njulia> FourierTools.center_extract([1 2; 3 4], [1, 1])\n1×1 view(::Matrix{Int64}, 2:2, 2:2) with eltype Int64:\n 4\n\njulia> FourierTools.center_extract([1 2 3; 3 4 5; 6 7 8], [2 2])\n2×2 view(::Matrix{Int64}, 1:2, 1:2) with eltype Int64:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.odd_view","page":"Utility Functions","title":"FourierTools.odd_view","text":"odd_view(arr)\n\ncreates a view of arr that for each even dimension excludes the starting index yielding a view of the array with only odd dimensions. This is useful for operations in Fourier-space which should leave the first index unaltered such as reverse! Note that an array reversal can also be achieved by using two ffts instead of one fft and one ifft.\n\nExamples\n\njulia> odd_view([1 2 3; 4 5 6])\n1×3 view(::Matrix{Int64}, 2:2, 1:3) with eltype Int64:\n 4  5  6\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.fourier_reverse!","page":"Utility Functions","title":"FourierTools.fourier_reverse!","text":"fourier_reverse!(arr; dims=1:ndims(arr))\n\nreverses the dimensions of the input array arr in place. This effectively mirrors these array. Note that for even-sized dimensions the first index is excluded from the reverse operation along this dimensions. \n\nExample\n\njulia> a = [1 2 3;4 5 6;7 8 9;10 11 12]\n4×3 Matrix{Int64}:\n  1   2   3\n  4   5   6\n  7   8   9\n 10  11  12\n\njulia> fourier_reverse!(a);\n\njulia> a\n4×3 Matrix{Int64}:\n  3   2   1\n 12  11  10\n  9   8   7\n  6   5   4\n\n\n\n\n\n","category":"function"},{"location":"utils/#FourierTools.get_indexrange_around_center","page":"Utility Functions","title":"FourierTools.get_indexrange_around_center","text":"get_indexrange_around_center(arr_1, arr_2)\n\nA function which provides a range of output indices i1:i2 where i2 - i1 = i_out The indices are chosen in a way that the set i1:i2 cuts the interval 1:i_in such that the center frequency stays at the center position. Works for both odd and even indices\n\n\n\n\n\n","category":"function"},{"location":"nfft/#NFFT-helpers","page":"NFFT","title":"NFFT helpers","text":"Based on NFFT.jl we provide some convenient helper functions:","category":"section"},{"location":"nfft/#FourierTools.nfft_nd","page":"NFFT","title":"FourierTools.nfft_nd","text":"nfft_nd(src, dst_coords, dst_size=nothing; is_in_pixels=false, is_local_shift=false)\n\nperforms an n-dimensional non-uniform FFT on grids with a regular topology. In comparison to the nfft() routine, which this computed is based on, this version does not require any reshape operations. See plan_nfft_nd for details on the arguments and usage examples. Note that the input can be Real valued and will be automatically converted to Complex.\n\n# A Zoomed transform in 3D\njulia> nfft_nd(rand(10,12,12), (t)-> (0.8*t[1], 0.7*t[2], 0.6*t[3]))\n\n\n\n\n\n","category":"function"},{"location":"nfft/#FourierTools.plan_nfft_nd","page":"NFFT","title":"FourierTools.plan_nfft_nd","text":"plan_nfft_nd(src, dst_coords; is_in_pixels=false, is_local_shift=false, pad_value=nothing, reltol=1e-9)\n\nPlans an n-dimensional non-uniform FFT on grids with a regular topology. In comparison to the nfft() routine, which this computed is based on, this version does not require any reshape operations.\n\nArguments\n\nsrc: source array\ndst_coords: array of destination coordinates. This can be either an Array of Tuple or an Array with the last dimension ofsizelength(size(dst_coords))-1`  referring to the destination coordinates where the FFT needs to be computed.  Alternatively also a function mapping a tuple (of source index positions) to a tuple (of destination index positions). In the recommended mode, the indices are normalized to to Fouier frequency range (roughly speaking from -0.5:0.5).\nis_in_pixels: A Boolean flag indicating whether dstcoords refers to coordinates in pixels or (default) in relative frequency positions. If `isin_pixels=true` is selected, destination coordinates (1-based indexing) as typical for array indexing is assumed and internally converted to relative positions.\nis_local_shift: A Boolean controlling wether dst_coords refers to the destination coordinates or the relative distance from standard grid coordinates (size determind from dst_coordinates).  \npad_value: if supplied, values outside the valid pixel range (roughly -0.5:0.5) are replaced by this complex-valued pad value.\nis_adjoint: if true this plan is based on the adjoint rather than the ordinary plan\nreltol: The numerical precision to which the results are computed. This is passed to the nfft routine. Worse precision is faster.\n\n# Lets try a 2D rotation:\njulia> using TestImages, NDTools, View5D, IndexFunArrays, FourierTools\n\njulia> img = Float64.(testimage(\"resolution\"));\n\n# define a rotation operation\njulia> rot_alpha(a, t) = (cosd(a)*t[1] - sind(a)*t[2], sind(a)*t[1]+cosd(a)*t[2])\n\njulia> new_pos = rot_alpha.(10.0, idx(img, scale=ScaFT))\n\njulia> f = ift(img)\n\njulia> p = plan_nfft_nd(f, new_pos; is_local_shift=false, is_in_pixels=false)\n\njulia> g = real.(p * f)\n\n#display the result\njulia> @ve img, g\n\n\n\n\n\nplan_nfft_nd(src::AbstractArray{T,D}, dst_fkt::Function, dst_size=size(src); is_in_pixels=false, is_adjoint=false, kwargs...)\n\nPlans an n-dimensional non-uniform FFT on grids with a regular topology defined via the function dst_fkt.\n\nArguments\n\nsrc: source array\ndst_fkt: a function mapping a tuple (of source index positions) to a tuple (of destination index positions).   In the recommended mode, the indices are normalized to to Fouier frequency range (roughly speaking from -0.5:0.5). If the named argument is_in_pixels is provided,   the function is expected to act on one-index based pixel coordinates. This option is particularly interesting in combination with the argument is_loca_shift.\ndst_size: this argument is only used for functions. If you require a different result size for dst_coords being a function, state it here.By defaul (dst_size=nothing) the    destination size will be inferred form the argument new_pos or assumed to be size(src).\nis_in_pixels: A Boolean flag indicating whether dstcoords refers to coordinates in pixels or (default) in relative frequency positions.   If `isin_pixels=true` is selected, destination coordinates (1-based indexing) as typical for array indexing is assumed and internally converted to relative positions.\nis_adjoint: if true this plan is based on the adjoint rather than the ordinary plan\n\nFor other arguments and examples see the array-version of plan_nfft above.\n\n\n\n\n\n","category":"function"},{"location":"slidingdft/#Sliding-Discrete-Fourier-Transforms","page":"Sliding Discrete Fourier Transforms","title":"Sliding Discrete Fourier Transforms","text":"Computation of Sliding Discrete Fourer Transforms over one-dimensional series of values.","category":"section"},{"location":"slidingdft/#Usage","page":"Sliding Discrete Fourier Transforms","title":"Usage","text":"The basic Sliding Discrete Fourier Transform (SDFT) of a one-dimensional series of values x, using a window of length n, is calculated as follows:\n\nStep 1: Setup the method for an SDFT of length n:\n\nsdft = SDFT(n)\n\nStep 2: Apply the created method to the data series x. This is typically used in a loop:\n\nfor spectrum in sdft(x)\n    # `spectrum` is a `Vector{Complex(eltype(x))}` of length `n`\nend","category":"section"},{"location":"slidingdft/#Considerations-for-stateful-iterators","page":"Sliding Discrete Fourier Transforms","title":"Considerations for stateful iterators","text":"By default, SDFTs are computed traversing sequentially the data series x, which can be any kind of iterator. In the case of stateful iterators (i.e. those that are modified upon each iteration, like Base.Channels),  sdft(method, x) will also be a stateful iterator that will \"consume\" as many items of x as the length of the computed DFT in the first iteration, and one additional item in every subsequent iteration.\n\nApart from that consideration, it is safe to apply SDFTs to stateful iterators, since past samples of x already used in previous iterations, which are often required for the computations, are temporarily stored in an array — in internal variables that users do not need to deal with.","category":"section"},{"location":"slidingdft/#Methods-for-SDFTs","page":"Sliding Discrete Fourier Transforms","title":"Methods for SDFTs","text":"","category":"section"},{"location":"slidingdft/#Developing-new-SDFTs","page":"Sliding Discrete Fourier Transforms","title":"Developing new SDFTs","text":"","category":"section"},{"location":"slidingdft/#Theoretical-basis","page":"Sliding Discrete Fourier Transforms","title":"Theoretical basis","text":"An SDFT is generally implemented as a recursive equation, such that if X_ik is the DFT of xj for j = i ldots i+n at frequency k, the next iteration is:\n\nX_i+1k = f(k X_1k ldots X_ik xi ldots xi+n xi+n+1)\n\nSuch an equation depends on:\n\nThe frequency k\nThe values of the DFT in one or more previous iterations, X_pk for p = 1 ldots i.\nThe values of the data series used in the most recent iteration, xj for j = i ldots i+n.\nThe next value of the data series after the fragment used in the most recent iteration, xi+n+1.\n\nFor instance, the basic definition of the SDFT uses the following formula: \n\nX_i+1k = Wk cdot (X_ik + xi+n - xi)\n\nwhich depends only on the most recent DFT (X_ik), the first data point of the fragment used in that DFT (xi), and the next data point after that fragment (xi+n+1), plus a \"twiddle\" factor Wk that only depends on the frequency k, equal to exp(j2pikn). Other variations of the SDFT may use formulas that depend on previous iterations or other values of the data series in that fragment.","category":"section"},{"location":"slidingdft/#Implementation-in-Julia-object-types","page":"Sliding Discrete Fourier Transforms","title":"Implementation in Julia object types","text":"A method to compute an SDFT is defined by three kinds of object types:\n\nOne for the method (e.g. sdft = SDFT(n) in the previous example), which contains the fixed parameters that are needed by the algorithm to compute the SDFT.\nAnother for the iterator created by calling the method as a function (sdft(x) in the example), which is thus bound with the target data series.\nAnd yet another for the state of the iterator, which holds the information needed by the algorithm that depends on the data series and changes at each iteration.\n\nThe internals of this package take care of the design of the iterator and state types, and of the creation of their instances. The only thing that has to be defined to create a new kind of SDFT is the struct of the method with the fixed parameters, and a few function methods dispatching on that type.\n\nBefore explaining how to define such a struct, it is convenient to know the functions that can be used to extract the information that is stored in the state of SDFT iterators. There is a function for each one of the three kinds of variables presented in the general recursive equation above.\n\nFourierTools.sdft_previousdft for the values of the DFT in previous iterations.\nFourierTools.sdft_previousdata for the values of the data series used in the most recent iteration.\nFourierTools.sdft_nextdata for the next value of the data series after the fragment used in the most recent iteration.\n\nFor instance, the values used in the formula of the basic SDFT may be obtained from a state object as:\n\nFourierTools.sdft_previousdft(state, 0) for X_i.\nFourierTools.sdft_previousdata(state, 0) for xi.\nFourierTools.sdft_nextdata(state) for xi+n+1.\n\nNotice that the second arguments of sdft_previousdft and sdft_previousdata might have been ommited in this case, since they are zero by default.\n\nFor methods that need to know how many steps of the SDFT have been done, this can also be extracted with the function FourierTools.sdft_iteration.\n\nThe design of the struct representing a new SDFT type is free, but it is required to be a subtype of AbstractSDFT, and implement the following methods dispatching on that type:\n\nFourierTools.sdft_windowlength to return the length of the DFT window.\nFourierTools.sdft_update! with the implementation of the recursive equation, extracting the information stored in the state with the functions commented above (sdft_previousdft, etc.) .\n\nDepending on the functions that are used in the particular implementation of sdft_update! for a given type, the following methods should be defined too:\n\nFourierTools.sdft_backindices if FourierTools.sdft_previousdft is used.\nFourierTools.sdft_dataoffsets if FourierTools.sdft_previousdata is used.","category":"section"},{"location":"slidingdft/#Example","page":"Sliding Discrete Fourier Transforms","title":"Example","text":"The formula of the basic SDFT formula could be implemented for a type MyBasicSDFT as follows:\n\nimport FourierTools: sdft_update!, sdft_windowlength, sdft_nextdata, sdft_previousdata\n\nfunction sdft_udpatedft!(dft, x, method::MyBasicSDFT, state)\n    n = sdft_windowlength(method)\n    for k in eachindex(dft)\n        X_i = dft[k]\n        x_iplusn = sdft_nextdata(state)\n        x_i = sdft_previousdata(state)\n        Wk = exp(2π*im*k/n)\n        dft[k] = Wk * (X_i + x_iplusn - x_i)\n    end\nend\n\n(The type SDFT actually has as a similar, but not identical definition.)\n\nThe implementation of sdft_update! given in the previous example does use sdft_previousdata - with the default offset value, equal to zero - so the following is required in this case:\n\nFourierTools.sdft_dataoffsets(::MyBasicSDFT) = 0\n\nOn the other hand there is no need to define FourierTools.sdft_backindices in this case, since the interface of of sdft_update! assumes that the most recent DFT is already contained in its first argument dft, so it is not necessary to use the function sdft_previousdft to get it.","category":"section"},{"location":"slidingdft/#Alternative-to-subtyping-AbstractSDFT","page":"Sliding Discrete Fourier Transforms","title":"Alternative to subtyping AbstractSDFT","text":"Types that represent SDFT methods are required to be subtypes of AbstractSDFT in order to make them callable and return an iterator of the SDFT (i.e. objects of the type FourierTools.SDFTIterator). If for some reason that subtyping is not desired or possible (e.g. if the said type already has another supertype), the same behavior can be obtained by defining them explicitly as functors, in the following fashion:\n\n(m::MyBasicSDFT)(args...) = FourierTools.SDFTIterator(args...)","category":"section"},{"location":"slidingdft/#SDFT-development-API","page":"Sliding Discrete Fourier Transforms","title":"SDFT development API","text":"","category":"section"},{"location":"slidingdft/#FourierTools.SDFT","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.SDFT","text":"SDFT(n)\nSDFT(C, n)\n\nBasic method to compute a Sliding Discrete Fourier Transform of window length n, through the recursive formula:\n\nX_i+1k = e^j2pikn cdot (X_ik + xi+n - xi)\n\nThe transfer function for the k-th bin of this method is:\n\nH(z) = frac1 - z^-n1 - e^j2pikn z^-1\n\nUse SDFT(C, n) to obtain results with the precision of the complex data type C. C == ComplexF64 by default.\n\nSDFT is a subtype of AbstractSDFT. See the documentation of that type for further details about its usage.\n\nReferences\n\nJacobsen, E. & Lyons, R. (2003). \"The sliding DFT,\" IEEE Signal Processing Magazine, 20(2), 74-80. doi:10.1109/MSP.2003.1184347\n\n\n\n\n\n","category":"type"},{"location":"slidingdft/#FourierTools.AbstractSDFT","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.AbstractSDFT","text":"(m::AbstractSDFT)(x[, safe=true])\n\nAbstractSDFT is an abstract type for callable structs that implement Sliding Discrete Fourier Transforms.\n\nIf typeof(m) <: AbstractSDFT, then m(x) will return an iterator that produces a sliding DFT of x according to the method m. \n\nBy default that iterator produces a new vector at each iteration. Set the optional argument safe=false to improve performance by reducing allocations, at the expense of unexpected behavior if the resulting vector is mutated between iterations.\n\nExample\n\nsdft = SDFT(10) # basic [`SDFT`](@ref) with a window of length 10\n\nfor dft in sdft(x)\n    # here `dft` is a vector with 10 complex values\nend\n\nAvailable methods:\n\nSee some methods for sliding DFTs at: https://nanoimaging.de/FourierTools.jl/stable/slidingdft/#Methods-for-SDFTs\n\n\n\n\n\n","category":"type"},{"location":"slidingdft/#FourierTools.SDFTIterator","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.SDFTIterator","text":"SDFTIterator(method, x[, safe=true])\n\nReturn an iterator to produce a sliding DFT of x using the given method. If safe == true (the default value), this iterator produces a new vector at each iteration; otherwise the vector produced in the first iteration can be reused in subsequent iterations.\n\n\n\n\n\n","category":"type"},{"location":"slidingdft/#FourierTools.sdft_backindices-Tuple{Any}","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_backindices","text":"sdft_backindices(method)\n\nReturn an integer or a vector of positive integers with the indices of the previous iterations that are needed by the given method to compute a sliding DFT.\n\nIf the code of FourierTools.updatepdf! for the type of method uses the function FourierTools.sdft_previousdft, this function must return the integers that are used as the third argument (back) of that function.\n\nIf that function is not needed, this one may return nothing to reduce memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"slidingdft/#FourierTools.sdft_dataoffsets-Tuple{Any}","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_dataoffsets","text":"sdft_dataoffsets(method)\n\nReturn an integer or a vector of integers with the offsets of data samples that are needed by the given method to compute a sliding DFT.\n\nIf the code of FourierTools.updatepdf! that dispatches on the type of method uses the function FourierTools.sdft_previousdata, this function must return the integers that are used as the third argument (offset) of that function.\n\nIf that function is not needed (no past samples are used), this one may return nothing to reduce memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"slidingdft/#FourierTools.sdft_iteration-Tuple{Any}","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_iteration","text":"sdft_iteration(state)\n\nReturn the number of iterations done for the sliding DFT represented by state.\n\nIf the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions i and i+n, then this function returns  the number i.\n\n\n\n\n\n","category":"method"},{"location":"slidingdft/#FourierTools.sdft_nextdata-Tuple{FourierTools.SDFTStateData}","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_nextdata","text":"sdft_nextdata(state)\n\nReturn the next value after the fragment of the data series that was used in the most recent iteration of the sliding DFT represented by state.\n\nIf the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions i and i+n, then this function returns the i+n+1-th value.\n\nThere is no defined behavior if such value does not exist (i.e. if the end of a finite data series was reached).\n\n\n\n\n\n","category":"method"},{"location":"slidingdft/#FourierTools.sdft_previousdata","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_previousdata","text":"sdft_previousdata(state[, offset=0])\n\nReturn the first value of the fragment of the data series that was used in the most recent iteration of the sliding DFT represented by state, or at offset positions after the beginning of that fragment.\n\nIf the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions i and i+n, then this function returns the i+offset-th value.\n\n\n\n\n\n","category":"function"},{"location":"slidingdft/#FourierTools.sdft_previousdft","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_previousdft","text":"sdft_previousdft(state[, back=0])\n\nReturn the DFT computed in the most recent iteration of the sliding DFT represented by state, or in a number of previous iterations equal to back.\n\nIf the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions i and i+n, then this function returns its DFT for the fragment between i-back and i+n-back.\n\n\n\n\n\n","category":"function"},{"location":"slidingdft/#FourierTools.sdft_update!","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_update!","text":"sdft_update!(dft, x, method, state)\n\nUpdate the values of a sliding Discrete Fourier Transform (DFT) of a data series, according to the algorithm of the provided method, for a given state of the sliding DFT.\n\ndft is a mutable collection of complex values with length equal to sdft_windowlength(method), containing the value returned by the last iteration of the sliding DFT.\n\nx is the data series for which the sliding DFT is computed, at least as long as sdft_windowlength(method).\n\nmethod is the object that defines the method to compute the sliding DFT.\n\nstate is an object generated automatically at each iteration of an SDFT iterator made from method and x, (an object of the type FourierTools.SDFTIterator).\n\nThe information that is needed to update the sliding DFT can be extracted from state with the following functions:\n\nFourierTools.sdft_previousdft to get the DFTs of previous iterations.\nFourierTools.sdft_previousdata to get a previous value of the data series.\nFourierTools.sdft_nextdata to get the next value of the data series.\n\n\n\n\n\n","category":"function"},{"location":"slidingdft/#FourierTools.sdft_windowlength","page":"Sliding Discrete Fourier Transforms","title":"FourierTools.sdft_windowlength","text":"sdft_windowlength(method)\n\nReturn the length of the window used by method.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FFT-helpers","page":"FFT Helpers","title":"FFT helpers","text":"","category":"section"},{"location":"helpers/#FFT-Utils","page":"FFT Helpers","title":"FFT Utils","text":"","category":"section"},{"location":"helpers/#FFT-Helpers-2D","page":"FFT Helpers","title":"FFT Helpers 2D","text":"","category":"section"},{"location":"helpers/#FourierTools.ffts","page":"FFT Helpers","title":"FourierTools.ffts","text":"ffts(A [, dims])\n\nResult is semantically equivalent to fftshift(fft(A, dims), dims) However, the shift is done with MutableShiftedArrays and therefore doesn't allocate memory.\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ffts!","page":"FFT Helpers","title":"FourierTools.ffts!","text":"ffts!(A [, dims])\n\nResult is semantically equivalent to fftshift(fft!(A, dims), dims). A is in-place modified. However, the shift is done with MutableShiftedArrays and therefore doesn't allocate memory.\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.iffts","page":"FFT Helpers","title":"FourierTools.iffts","text":"iffts(A [, dims])\n\nResult is semantically equivalent to ifft(ifftshift(A, dims), dims). A is in-place modified. However, the shift is done with MutableShiftedArrays and therefore doesn't allocate memory.\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rffts","page":"FFT Helpers","title":"FourierTools.rffts","text":"rffts(A [, dims])\n\nCalculates a rfft(A, dims) and then shift the frequencies to the center. dims[1] is not shifted, because there is no negative and positive frequency. The shift is done with MutableShiftedArrays and therefore doesn't allocate memory.\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irffts","page":"FFT Helpers","title":"FourierTools.irffts","text":"irffts(A, d, [, dims])\n\nCalculates a irfft(A, d, dims) and then shift the frequencies back to the corner. dims[1] is not shifted, because there is no negative and positive frequency. The shift is done with MutableShiftedArrays and therefore doesn't allocate memory.\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fftshift_view","page":"FFT Helpers","title":"FourierTools.fftshift_view","text":"fftshift_view(A [, dims])\n\nResult is semantically equivalent to fftshift(A, dims) but returns  a view instead. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ifftshift_view","page":"FFT Helpers","title":"FourierTools.ifftshift_view","text":"ifftshift_view(A [, dims])\n\nResult is semantically equivalent to fftshift(A, dims) but returns  a view instead. \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rfftshift_view","page":"FFT Helpers","title":"FourierTools.rfftshift_view","text":"rfftshift_view(A, dims)\n\nShifts the frequencies to the center expect for dims[1] because there os no negative and positive frequency.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irfftshift_view","page":"FFT Helpers","title":"FourierTools.irfftshift_view","text":"irfftshift_view(A, dims)\n\nShifts the frequencies back to the corner except for dims[1] because there os no negative and positive frequency.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ft","page":"FFT Helpers","title":"FourierTools.ft","text":"ft(A [, dims])\n\nDigital Fourier-transformation centered in both spaces. The result is semantically equivalent to fftshift(fft(ifftshift(A, dims), dims), dims) This is a digital Fourier transformation with both coordinate systems in real and Fourier-space being centered at position CtrFT == size÷2+1\n\nThe following identities are true:\n\njulia> sz = (5,5)\n(5, 5)\n\njulia> ft(ones(sz)) ≈ prod(sz) .* δ(sz)\ntrue\n\njulia> ft(δ(sz)) ≈ ones(sz)\ntrue\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ift","page":"FFT Helpers","title":"FourierTools.ift","text":"ift(A [, dims])\n\nDigital inverse Fourier-transformation centered in both spaces. The result is semantically equivalent to fftshift(ifft(ifftshift(A, dims), dims), dims) This is a digital Fourier transformation with both coordinate systems in real and Fourier-space being centered at position CtrFT == size÷2+1\n\nThe following identities are true:\n\njulia> sz = (5,6,7)\n(5, 6, 7)\n\njulia> ift(ones(sz)) ≈ δ(sz)\ntrue\n\njulia> ift(δ(sz)) ≈ ones(sz) ./ prod(sz)\ntrue\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rft","page":"FFT Helpers","title":"FourierTools.rft","text":"rft(A [, dims])\n\nDigital real-valued Fourier-transformation centered in both spaces. The result is semantically equivalent to fftshift(rfft(ifftshift(A, dims), dims), dims) This is a digital Fourier transformation with the coordinate systems in real space centered at CtrFT == size÷2+1 and in (half) Fourier-space being centered at CtrRFT == setindex(size÷2 +1,1,1).\n\nThe following identities are true:\n\njulia> sz = (6,6)\n(6, 6)\n\njulia> rft(δ(sz)) ≈ ones(rft_size(sz))\ntrue\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irft","page":"FFT Helpers","title":"FourierTools.irft","text":"irft(A, d, [, dims])\n\nDigital real-valued inverse Fourier-transformation centered in both spaces. The result is semantically equivalent to fftshift(irfft(ifftshift(A, dims), dims), dims) This is a digital Fourier transformation with the coordinate systems in real space centered at CtrFT == size÷2+1 and in (half) Fourier-space being centered at CtrRFT == setindex(size÷2 +1,1,1). Note that the size d of the first transform direction [1] is a required argument.\n\nThe following identities are true:\n\njulia> sz = (6,6)\n(6, 6)\n\njulia> irft(ones(rft_size(sz)),sz[1]) ≈ δ(sz)\ntrue\n\nSee also: ft, ift, rft, irft,           ffts,  iffts,  ffts!, rffts, irffts, \n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fftpos","page":"FFT Helpers","title":"FourierTools.fftpos","text":"fftpos(L, N, around=CenterFirst::Center)\n\nConstruct a range from -L/2 to L/2 around around\n\nHowever, we ensure that those positions are in a way which they are useful for FFT operations. This means, that depending on the center a small  offset is subtracted.\n\nSee NDTools.Center for all center options. You need to load using NDTools to access all center options.\n\nExamples\n\njulia> collect(fftpos(1,4))\n4-element Vector{Float64}:\n 0.0\n 0.2916666666666667\n 0.5833333333333334\n 0.875\n\njulia> collect(fftpos(1,5))\n5-element Vector{Float64}:\n 0.0\n 0.225\n 0.45\n 0.675\n 0.9\n\njulia> using NDTools\n\njulia> collect(fftpos(1,4, CenterFirst))\n4-element Vector{Float64}:\n 0.0\n 0.2916666666666667\n 0.5833333333333334\n 0.875\n\njulia> collect(fftpos(1,4, CenterFT))\n4-element Vector{Float64}:\n -0.5833333333333333\n -0.29166666666666663\n  3.70074341541719e-17\n  0.2916666666666667\n\njulia> collect(fftpos(1,4, CenterMiddle))\n4-element Vector{Float64}:\n -0.4375\n -0.14583333333333334\n  0.14583333333333334\n  0.4375\n\n\n\n\n\nfftpos(l, N, around)\n\nAnother fftpos method where the range is constructed around around. around is here a number indicating the index position around the range is constructed\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fft_center","page":"FFT Helpers","title":"FourierTools.fft_center","text":"fft_center(x)\n\nReturns the center of a size in Fourier sense and Julia  1-based indices.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rft_size","page":"FFT Helpers","title":"FourierTools.rft_size","text":"rft_size(sz::NTuple{Int})\n\nReturns the size of an rft or rfft performed on the data x, without performing the rfft. sz: corresponding real space size to obtain the rft size for\n\n\n\n\n\nrft_size(arr)\n\nReturns the size of an rft or rfft performed on the data x, without performing the rfft.\n\narr: array to optain the corresponding rft size for\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rfft_size","page":"FFT Helpers","title":"FourierTools.rfft_size","text":"rfft_size(size, dims)\n\nReturns the size rfft would return if applied to a real array. size is the input size to rfft  and dims the dimensions the rfft transforms over. Actually we only would need first(dims).\n\njulia> using FFTW\n\njulia> rfft((ones((4,3,2))), (2,3)) |> size\n(4, 2, 2)\n\njulia> FourierTools.rfft_size((4,3,2), (2, 3))\n(4, 2, 2)\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ft_center_diff","page":"FFT Helpers","title":"FourierTools.ft_center_diff","text":"ft_center_diff(s [, dims])\n\nCalculates how much each dimension must be shifted that the center frequency is at the Fourier center. This if for a normal fft\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rft_center_diff","page":"FFT Helpers","title":"FourierTools.rft_center_diff","text":"rft_center_diff(s [, dims])\n\nCalculates how much each dimension must be shifted that the center frequency is at the Fourier center. This is for rfft. The dims[1] must be therefore not shifted!\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.center_pos","page":"FFT Helpers","title":"FourierTools.center_pos","text":"center_pos(x)\n\nCalculate the position of the center frequency. Size of the array is x\n\nExamples\n\njulia> FourierTools.center_pos(3)\n2\njulia> FourierTools.center_pos(4)\n3\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fftshift2d","page":"FFT Helpers","title":"FourierTools.fftshift2d","text":"fftshift2d(mat::AbstractArray{T, N}) where {T, N}\n\nShort-hand for fftshift(mat, (1,2)). See fftshift for details.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ifftshift2d","page":"FFT Helpers","title":"FourierTools.ifftshift2d","text":"ifftshift2d(mat::AbstractArray{T, N}) where {T, N}\n\nShort-hand for ifftshift(mat, (1,2)). See ifftshift for details.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fftshift2d_view","page":"FFT Helpers","title":"FourierTools.fftshift2d_view","text":"fftshift2d_view(mat::AbstractArray{T, N}) where {T, N}\n\nShort-hand for fftshift_view(mat, (1,2)). See fftshift_view for details.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ifftshift2d_view","page":"FFT Helpers","title":"FourierTools.ifftshift2d_view","text":"ifftshift2d_view(mat::AbstractArray{T, N}) where {T, N}\n\nShort-hand for ifftshift_view(mat, (1,2)) performing only a 2D inverse ft. See ifft for details.\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.fft2d","page":"FFT Helpers","title":"FourierTools.fft2d","text":"fft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ifft2d","page":"FFT Helpers","title":"FourierTools.ifft2d","text":"ifft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rfft2d","page":"FFT Helpers","title":"FourierTools.rfft2d","text":"rfft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irfft2d","page":"FFT Helpers","title":"FourierTools.irfft2d","text":"irfft2d(mat::AbstractArray{T, N}, d) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ffts2d","page":"FFT Helpers","title":"FourierTools.ffts2d","text":"ft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ffts2d!","page":"FFT Helpers","title":"FourierTools.ffts2d!","text":"fft2ds!(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.iffts2d","page":"FFT Helpers","title":"FourierTools.iffts2d","text":"iffts2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rffts2d","page":"FFT Helpers","title":"FourierTools.rffts2d","text":"rffts2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irffts2d","page":"FFT Helpers","title":"FourierTools.irffts2d","text":"riffts2d(mat::AbstractArray{T, N}, d) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ft2d","page":"FFT Helpers","title":"FourierTools.ft2d","text":"ft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.ift2d","page":"FFT Helpers","title":"FourierTools.ift2d","text":"ift2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.rft2d","page":"FFT Helpers","title":"FourierTools.rft2d","text":"rft2d(mat::AbstractArray{T, N}) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"helpers/#FourierTools.irft2d","page":"FFT Helpers","title":"FourierTools.irft2d","text":"irft2d(mat::AbstractArray{T, N}, d) where {T, N}\n\nOnly over dims=(1,2).\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#Function-References","page":"FFT Based Convolutions and Cross-Correlation","title":"Function References","text":"","category":"section"},{"location":"convolutions/#FourierTools.conv","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.conv","text":"conv(u, v[, dims])\n\nConvolve u with v over dims dimensions with an FFT based method. Note, that this method introduces wrap-around artifacts without proper padding/windowing.\n\nArguments\n\nu is an array in real space.\nv is the array to be convolved in real space as well.\nPer default ntuple(+, min(N, M))) means that we perform the convolution    over all dimensions of that array which has less dimensions.    If dims is an array with integers, we perform convolution    only over these dimensions. Eg. dims=[1,3] would perform the convolution   over the first and third dimension. Second dimension is not convolved.\n\nIf u and v are both a real valued array we use rfft and hence the output is real as well. If either u or v is complex we use fft and output is hence complex.\n\nExamples\n\n1D with FFT over all dimensions. We choose v to be a delta peak. Therefore convolution should act as identity.\n\njulia> u = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\njulia> v = [0 0 1 0 0]\n1×5 Array{Int64,2}:\n 0  0  1  0  0\n\njulia> conv(u, v)\n1×5 Matrix{Float64}:\n 4.0  5.0  1.0  2.0  3.0\n\n2D with FFT with different dims arguments.\n\njulia> u = 1im .* [1 2 3; 4 5 6]\n2×3 Matrix{Complex{Int64}}:\n 0+1im  0+2im  0+3im\n 0+4im  0+5im  0+6im\n\njulia> v = [1im 0 0; 1im 0 0]\n2×3 Matrix{Complex{Int64}}:\n 0+1im  0+0im  0+0im\n 0+1im  0+0im  0+0im\n\njulia> conv(u, v)\n2×3 Matrix{ComplexF64}:\n -5.0+0.0im  -7.0+0.0im  -9.0+0.0im\n -5.0+0.0im  -7.0+0.0im  -9.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.ccorr","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.ccorr","text":"ccorr(u, v[, dims]; centered=false)\n\nCalculates the cross-correlation between u and v along dims. centered=true moves the output of the cross-correlation to the Fourier center.\n\nIf u and v are both a real valued array we use rfft and hence the output is real as well. If either u or v is complex we use fft and output is hence complex.\n\nPer default the correlation is performed along min(ndims(u), ndims(v)).\n\njulia> ccorr([1,1,0,0], [1,1,0,0], centered=true)\n4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 1.0\n\njulia> ccorr([1,1,0,0], [1,1,0,0])\n4-element Vector{Float64}:\n 2.0\n 1.0\n 0.0\n 1.0\n\njulia> ccorr([1im,0,0,0], [0,1im,0,0])\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n\njulia> ccorr([1im,0,0,0], [0,1im,0,0], centered=true)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.conv_psf","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.conv_psf","text":"conv_psf(u, psf[, dims])\n\nconv_psf is a shorthand for conv(u,ifftshift(psf)). For examples see conv.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.plan_conv","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.plan_conv","text":"plan_conv(u, v [, dims]; kwargs...)\n\nPre-plan an optimized convolution for arrays shaped like u and v (based on pre-plan FFT) along the given dimenions dims. dims = 1:ndims(u) per default. The 0 frequency of u must be located at the first entry.\n\nWe return two arguments:  The first one is v_ft (obtained by fft(v) or rfft(v)). The second return is the convolution function pconv. pconv itself has two arguments. pconv(u, v_ft=v_ft) where u is the object and v_ft the v_ft. This function achieves faster convolution than conv(u, u). Depending whether u is real or complex we do ffts or rffts Additionally, it is possible to provide flags=FFTW.MEASURE as kwargs  to change the planning of the FFT.\n\nExamples\n\njulia> u = [1 2 3 4 5]\n1×5 Matrix{Int64}:\n 1  2  3  4  5\n\njulia> v = [1 0 0 0 0]\n1×5 Matrix{Int64}:\n 1  0  0  0  0\n\njulia> v_ft, pconv = plan_conv(u, v);\n\njulia> pconv(u, v_ft)\n1×5 Matrix{Float64}:\n 1.0  2.0  3.0  4.0  5.0\n\njulia> pconv(u)\n1×5 Matrix{Float64}:\n 1.0  2.0  3.0  4.0  5.0\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.plan_conv_psf","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.plan_conv_psf","text":"plan_conv_psf(u, psf [, dims]; kwargs...) where {T, N}\n\nplan_conv_psf is a shorthand for plan_conv(u, ifftshift(psf)). For examples see plan_conv.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.plan_conv_buffer","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.plan_conv_buffer","text":"plan_conv_buffer(u, v [, dims]; kwargs...)\n\nSimilar to plan_conv but instead uses buffers to prevent memory allocations. The three buffers are internal to the function and are not exposed to the user. Not AD friendly!\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#FourierTools.plan_conv_psf_buffer","page":"FFT Based Convolutions and Cross-Correlation","title":"FourierTools.plan_conv_psf_buffer","text":"plan_conv_psf_buffer(u, psf [, dims]; kwargs...) where {T, N}\n\nplan_conv_psf_buffer is a shorthand for plan_conv_buffer(u, ifftshift(psf)). For examples see plan_conv.\n\n\n\n\n\n","category":"function"},{"location":"#FourierTools.jl","page":"FourierTools.jl","title":"FourierTools.jl","text":"This package contains various functions that are useful for working with and in Fourier space.\n\nInstall FourierTools.jl via the package manager. Currently with\n\njulia> add FourierTools \n\nCheck out the sub pages for different applications.","category":"section"}]
}
