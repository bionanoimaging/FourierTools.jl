<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sliding Discrete Fourier Transforms · FourierTools.jl</title><meta name="title" content="Sliding Discrete Fourier Transforms · FourierTools.jl"/><meta property="og:title" content="Sliding Discrete Fourier Transforms · FourierTools.jl"/><meta property="twitter:title" content="Sliding Discrete Fourier Transforms · FourierTools.jl"/><meta name="description" content="Documentation for FourierTools.jl."/><meta property="og:description" content="Documentation for FourierTools.jl."/><meta property="twitter:description" content="Documentation for FourierTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FourierTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">FourierTools.jl</a></li><li><a class="tocitem" href="../helpers/">FFT Helpers</a></li><li><a class="tocitem" href="../convolutions/">FFT Based Convolutions and Cross-Correlation</a></li><li><a class="tocitem" href="../resampling/">Resampling (sinc Interpolation)</a></li><li><a class="tocitem" href="../shifting/">Shifting with FFTs</a></li><li><a class="tocitem" href="../shear/">Image Shearing with FFTs</a></li><li><a class="tocitem" href="../rotate/">Image Rotation with FFTs</a></li><li><a class="tocitem" href="../nfft/">NFFT</a></li><li><a class="tocitem" href="../czt/">CZT</a></li><li><a class="tocitem" href="../fractional/">Fractional Fourier Transform</a></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li class="is-active"><a class="tocitem" href>Sliding Discrete Fourier Transforms</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Methods-for-SDFTs"><span>Methods for SDFTs</span></a></li><li><a class="tocitem" href="#Developing-new-SDFTs"><span>Developing new SDFTs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sliding Discrete Fourier Transforms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sliding Discrete Fourier Transforms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bionanoimaging/FourierTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bionanoimaging/FourierTools.jl/blob/main/docs/src/slidingdft.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sliding-Discrete-Fourier-Transforms"><a class="docs-heading-anchor" href="#Sliding-Discrete-Fourier-Transforms">Sliding Discrete Fourier Transforms</a><a id="Sliding-Discrete-Fourier-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Sliding-Discrete-Fourier-Transforms" title="Permalink"></a></h1><p>Computation of <a href="https://en.wikipedia.org/wiki/Sliding_DFT">Sliding Discrete Fourer Transforms</a> over one-dimensional series of values.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The basic Sliding Discrete Fourier Transform (SDFT) of a one-dimensional series of values <code>x</code>, using a window of length <code>n</code>, is calculated as follows:</p><p><strong>Step 1</strong>: Setup the method for an SDFT of length <code>n</code>:</p><pre><code class="language-julia hljs">sdft = SDFT(n)</code></pre><p><strong>Step 2</strong>: Apply the created method to the data series <code>x</code>. This is typically used in a loop:</p><pre><code class="language-julia hljs">for spectrum in sdft(x)
    # `spectrum` is a `Vector{Complex(eltype(x))}` of length `n`
end</code></pre><h3 id="Considerations-for-stateful-iterators"><a class="docs-heading-anchor" href="#Considerations-for-stateful-iterators">Considerations for stateful iterators</a><a id="Considerations-for-stateful-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Considerations-for-stateful-iterators" title="Permalink"></a></h3><p>By default, SDFTs are computed traversing sequentially the data series <code>x</code>, which can be any kind of iterator. In the case of stateful iterators (i.e. those that are modified upon each iteration, like <code>Base.Channel</code>s),  <code>sdft(method, x)</code> will also be a stateful iterator that will &quot;consume&quot; as many items of <code>x</code> as the length of the computed DFT in the first iteration, and one additional item in every subsequent iteration.</p><p>Apart from that consideration, it is safe to apply SDFTs to stateful iterators, since past samples of <code>x</code> already used in previous iterations, which are often required for the computations, are temporarily stored in an array — in internal variables that users do not need to deal with.</p><h2 id="Methods-for-SDFTs"><a class="docs-heading-anchor" href="#Methods-for-SDFTs">Methods for SDFTs</a><a id="Methods-for-SDFTs-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-SDFTs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.SDFT" href="#FourierTools.SDFT"><code>FourierTools.SDFT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDFT(n)
SDFT(C, n)</code></pre><p>Basic method to compute a Sliding Discrete Fourier Transform of window length <code>n</code>, through the recursive formula:</p><p class="math-container">\[X_{i+1}[k] = e^{j2{\pi}k/n} \cdot (X_{i}[k] + x[i+n] - x[i])\]</p><p>The transfer function for the <code>k</code>-th bin of this method is:</p><p class="math-container">\[H(z) = \frac{1 - z^{-n}}{1 - e^{j2{\pi}k/n} z^{-1}}\]</p><p>Use <code>SDFT(C, n)</code> to obtain results with the precision of the complex data type <code>C</code>. <code>C == ComplexF64</code> by default.</p><p><code>SDFT</code> is a subtype of <a href="#FourierTools.AbstractSDFT"><code>AbstractSDFT</code></a>. See the documentation of that type for further details about its usage.</p><p><strong>References</strong></p><p>Jacobsen, E. &amp; Lyons, R. (2003). &quot;The sliding DFT,&quot; <em>IEEE Signal Processing Magazine</em>, 20(2), 74-80. doi:<a href="https://doi.org/10.1109/MSP.2003.1184347">10.1109/MSP.2003.1184347</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_implementations.jl#L5-L28">source</a></section></article><h2 id="Developing-new-SDFTs"><a class="docs-heading-anchor" href="#Developing-new-SDFTs">Developing new SDFTs</a><a id="Developing-new-SDFTs-1"></a><a class="docs-heading-anchor-permalink" href="#Developing-new-SDFTs" title="Permalink"></a></h2><h3 id="Theoretical-basis"><a class="docs-heading-anchor" href="#Theoretical-basis">Theoretical basis</a><a id="Theoretical-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-basis" title="Permalink"></a></h3><p>An SDFT is generally implemented as a recursive equation, such that if <span>$X_{i}[k]$</span> is the DFT of <span>$x[j]$</span> for <span>$j = i, \ldots, i+n$</span> at frequency <span>$k$</span>, the next iteration is:</p><p class="math-container">\[X_{i+1}[k] = f(k, X_{1}[k], \ldots, X_{i}[k], x[i], \ldots x[i+n], x[i+n+1])\]</p><p>Such an equation depends on:</p><ul><li>The frequency <span>$k$</span></li><li>The values of the DFT in one or more previous iterations, <span>$X_{p}[k]$</span> for <span>$p = 1, \ldots, i$</span>.</li><li>The values of the data series used in the most recent iteration, <span>$x[j]$</span> for <span>$j = i, \ldots, i+n$</span>.</li><li>The next value of the data series after the fragment used in the most recent iteration, <span>$x[i+n+1]$</span>.</li></ul><p>For instance, the <a href="https://www.researchgate.net/publication/3321463_The_sliding_DFT">basic definition of the SDFT</a> uses the following formula: </p><p class="math-container">\[X_{i+1}[k] = W[k] \cdot (X_{i}[k] + x[i+n] - x[i]),\]</p><p>which depends only on the most recent DFT (<span>$X_{i}[k]$</span>), the first data point of the fragment used in that DFT (<span>$x[i]$</span>), and the next data point after that fragment (<span>$x[i+n+1]$</span>), plus a &quot;twiddle&quot; factor <span>$W[k]$</span> that only depends on the frequency <span>$k$</span>, equal to <span>$\exp(j2{\pi}k/n)$</span>. Other variations of the SDFT may use formulas that depend on previous iterations or other values of the data series in that fragment.</p><h3 id="Implementation-in-Julia-object-types"><a class="docs-heading-anchor" href="#Implementation-in-Julia-object-types">Implementation in Julia object types</a><a id="Implementation-in-Julia-object-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-Julia-object-types" title="Permalink"></a></h3><p>A method to compute an SDFT is defined by three kinds of object types:</p><ul><li>One for the method (e.g. <code>sdft = SDFT(n)</code> in the previous example), which contains the fixed parameters that are needed by the algorithm to compute the SDFT.</li><li>Another for the iterator created by calling the method as a function (<code>sdft(x)</code> in the example), which is thus bound with the target data series.</li><li>And yet another for the state of the iterator, which holds the information needed by the algorithm that depends on the data series and changes at each iteration.</li></ul><p>The internals of this package take care of the design of the iterator and state types, and of the creation of their instances. The only thing that has to be defined to create a new kind of SDFT is the <code>struct</code> of the method with the fixed parameters, and a few function methods dispatching on that type.</p><p>Before explaining how to define such a struct, it is convenient to know the functions that can be used to extract the information that is stored in the state of SDFT iterators. There is a function for each one of the three kinds of variables presented in the general recursive equation above.</p><ul><li><a href="#FourierTools.sdft_previousdft"><code>FourierTools.sdft_previousdft</code></a> for the values of the DFT in previous iterations.</li><li><a href="#FourierTools.sdft_previousdata"><code>FourierTools.sdft_previousdata</code></a> for the values of the data series used in the most recent iteration.</li><li><a href="#FourierTools.sdft_nextdata-Tuple{FourierTools.SDFTStateData}"><code>FourierTools.sdft_nextdata</code></a> for the next value of the data series after the fragment used in the most recent iteration.</li></ul><p>For instance, the values used in the formula of the basic SDFT may be obtained from a <code>state</code> object as:</p><ul><li><code>FourierTools.sdft_previousdft(state, 0)</code> for <span>$X_{i}$</span>.</li><li><code>FourierTools.sdft_previousdata(state, 0)</code> for <span>$x[i]$</span>.</li><li><code>FourierTools.sdft_nextdata(state)</code> for <span>$x[i+n+1]$</span>.</li></ul><p>Notice that the second arguments of <code>sdft_previousdft</code> and <code>sdft_previousdata</code> might have been ommited in this case, since they are zero by default.</p><p>For methods that need to know how many steps of the SDFT have been done, this can also be extracted with the function <a href="#FourierTools.sdft_iteration-Tuple{Any}"><code>FourierTools.sdft_iteration</code></a>.</p><p>The design of the <code>struct</code> representing a new SDFT type is free, but it is required to be a subtype of <a href="#FourierTools.AbstractSDFT"><code>AbstractSDFT</code></a>, and implement the following methods dispatching on that type:</p><ul><li><a href="#FourierTools.sdft_windowlength"><code>FourierTools.sdft_windowlength</code></a> to return the length of the DFT window.</li><li><a href="#FourierTools.sdft_update!"><code>FourierTools.sdft_update!</code></a> with the implementation of the recursive equation, extracting the information stored in the state with the functions commented above (<code>sdft_previousdft</code>, etc.) .</li></ul><p>Depending on the functions that are used in the particular implementation of <code>sdft_update!</code> for a given type, the following methods should be defined too:</p><ul><li><a href="#FourierTools.sdft_backindices-Tuple{Any}"><code>FourierTools.sdft_backindices</code></a> if <code>FourierTools.sdft_previousdft</code> is used.</li><li><a href="#FourierTools.sdft_dataoffsets-Tuple{Any}"><code>FourierTools.sdft_dataoffsets</code></a> if <code>FourierTools.sdft_previousdata</code> is used.</li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>The formula of the basic SDFT formula could be implemented for a type <code>MyBasicSDFT</code> as follows:</p><pre><code class="language-julia hljs">import FourierTools: sdft_update!, sdft_windowlength, sdft_nextdata, sdft_previousdata

function sdft_udpatedft!(dft, x, method::MyBasicSDFT, state)
    n = sdft_windowlength(method)
    for k in eachindex(dft)
        X_i = dft[k]
        x_iplusn = sdft_nextdata(state)
        x_i = sdft_previousdata(state)
        Wk = exp(2π*im*k/n)
        dft[k] = Wk * (X_i + x_iplusn - x_i)
    end
end</code></pre><p>(The type <a href="#FourierTools.SDFT"><code>SDFT</code></a> actually has as a similar, but not identical definition.)</p><p>The implementation of <code>sdft_update!</code> given in the previous example does use <code>sdft_previousdata</code> - with the default offset value, equal to zero - so the following is required in this case:</p><pre><code class="language-julia hljs">FourierTools.sdft_dataoffsets(::MyBasicSDFT) = 0</code></pre><p>On the other hand there is no need to define <code>FourierTools.sdft_backindices</code> in this case, since the interface of of <code>sdft_update!</code> assumes that the most recent DFT is already contained in its first argument <code>dft</code>, so it is not necessary to use the function <code>sdft_previousdft</code> to get it.</p><h3 id="Alternative-to-subtyping-AbstractSDFT"><a class="docs-heading-anchor" href="#Alternative-to-subtyping-AbstractSDFT">Alternative to subtyping <code>AbstractSDFT</code></a><a id="Alternative-to-subtyping-AbstractSDFT-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-to-subtyping-AbstractSDFT" title="Permalink"></a></h3><p>Types that represent SDFT methods are required to be subtypes of <code>AbstractSDFT</code> in order to make them callable and return an iterator of the SDFT (i.e. objects of the type <code>FourierTools.SDFTIterator</code>). If for some reason that subtyping is not desired or possible (e.g. if the said type already has another supertype), the same behavior can be obtained by defining them explicitly as <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">functors</a>, in the following fashion:</p><pre><code class="language-julia hljs">(m::MyBasicSDFT)(args...) = FourierTools.SDFTIterator(args...)</code></pre><h3 id="SDFT-development-API"><a class="docs-heading-anchor" href="#SDFT-development-API">SDFT development API</a><a id="SDFT-development-API-1"></a><a class="docs-heading-anchor-permalink" href="#SDFT-development-API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.AbstractSDFT" href="#FourierTools.AbstractSDFT"><code>FourierTools.AbstractSDFT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(m::AbstractSDFT)(x[, safe=true])</code></pre><p><code>AbstractSDFT</code> is an abstract type for callable structs that implement Sliding Discrete Fourier Transforms.</p><p>If <code>typeof(m) &lt;: AbstractSDFT</code>, then <code>m(x)</code> will return an iterator that produces a sliding DFT of <code>x</code> according to the method <code>m</code>. </p><p>By default that iterator produces a new vector at each iteration. Set the optional argument <code>safe=false</code> to improve performance by reducing allocations, at the expense of unexpected behavior if the resulting vector is mutated between iterations.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sdft = SDFT(10) # basic [`SDFT`](@ref) with a window of length 10

for dft in sdft(x)
    # here `dft` is a vector with 10 complex values
end</code></pre><p><strong>Available methods:</strong></p><p>See some methods for sliding DFTs at: https://nanoimaging.de/FourierTools.jl/stable/slidingdft/#Methods-for-SDFTs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L300-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.SDFTIterator" href="#FourierTools.SDFTIterator"><code>FourierTools.SDFTIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDFTIterator(method, x[, safe=true])</code></pre><p>Return an iterator to produce a sliding DFT of <code>x</code> using the given <code>method</code>. If <code>safe == true</code> (the default value), this iterator produces a new vector at each iteration; otherwise the vector produced in the first iteration can be reused in subsequent iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_backindices-Tuple{Any}" href="#FourierTools.sdft_backindices-Tuple{Any}"><code>FourierTools.sdft_backindices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_backindices(method)</code></pre><p>Return an integer or a vector of positive integers with the indices of the previous iterations that are needed by the given method to compute a sliding DFT.</p><p>If the code of <code>FourierTools.updatepdf!</code> for the type of <code>method</code> uses the function <code>FourierTools.sdft_previousdft</code>, this function must return the integers that are used as the third argument (<code>back</code>) of that function.</p><p>If that function is not needed, this one may return <code>nothing</code> to reduce memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_dataoffsets-Tuple{Any}" href="#FourierTools.sdft_dataoffsets-Tuple{Any}"><code>FourierTools.sdft_dataoffsets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_dataoffsets(method)</code></pre><p>Return an integer or a vector of integers with the offsets of data samples that are needed by the given method to compute a sliding DFT.</p><p>If the code of <code>FourierTools.updatepdf!</code> that dispatches on the type of <code>method</code> uses the function <code>FourierTools.sdft_previousdata</code>, this function must return the integers that are used as the third argument (<code>offset</code>) of that function.</p><p>If that function is not needed (no past samples are used), this one may return <code>nothing</code> to reduce memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_iteration-Tuple{Any}" href="#FourierTools.sdft_iteration-Tuple{Any}"><code>FourierTools.sdft_iteration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_iteration(state)</code></pre><p>Return the number of iterations done for the sliding DFT represented by <code>state</code>.</p><p>If the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions <code>i</code> and <code>i+n</code>, then this function returns  the number <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L143-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_nextdata-Tuple{FourierTools.SDFTStateData}" href="#FourierTools.sdft_nextdata-Tuple{FourierTools.SDFTStateData}"><code>FourierTools.sdft_nextdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_nextdata(state)</code></pre><p>Return the next value after the fragment of the data series that was used in the most recent iteration of the sliding DFT represented by <code>state</code>.</p><p>If the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions <code>i</code> and <code>i+n</code>, then this function returns the <code>i+n+1</code>-th value.</p><p>There is no defined behavior if such value does not exist (i.e. if the end of a finite data series was reached).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L128-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_previousdata" href="#FourierTools.sdft_previousdata"><code>FourierTools.sdft_previousdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_previousdata(state[, offset=0])</code></pre><p>Return the first value of the fragment of the data series that was used in the most recent iteration of the sliding DFT represented by <code>state</code>, or at <code>offset</code> positions after the beginning of that fragment.</p><p>If the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions <code>i</code> and <code>i+n</code>, then this function returns the <code>i+offset</code>-th value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_previousdft" href="#FourierTools.sdft_previousdft"><code>FourierTools.sdft_previousdft</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_previousdft(state[, back=0])</code></pre><p>Return the DFT computed in the most recent iteration of the sliding DFT represented by <code>state</code>, or in a number of previous iterations equal to <code>back</code>.</p><p>If the DFT computed in the most recent iteration corresponds to the fragment of the data series between its positions <code>i</code> and <code>i+n</code>, then this function returns its DFT for the fragment between <code>i-back</code> and <code>i+n-back</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_update!" href="#FourierTools.sdft_update!"><code>FourierTools.sdft_update!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_update!(dft, x, method, state)</code></pre><p>Update the values of a sliding Discrete Fourier Transform (DFT) of a data series, according to the algorithm of the provided method, for a given state of the sliding DFT.</p><p><code>dft</code> is a mutable collection of complex values with length equal to <code>sdft_windowlength(method)</code>, containing the value returned by the last iteration of the sliding DFT.</p><p><code>x</code> is the data series for which the sliding DFT is computed, at least as long as <code>sdft_windowlength(method)</code>.</p><p><code>method</code> is the object that defines the method to compute the sliding DFT.</p><p><code>state</code> is an object generated automatically at each iteration of an SDFT iterator made from <code>method</code> and <code>x</code>, (an object of the type <a href="#FourierTools.SDFTIterator"><code>FourierTools.SDFTIterator</code></a>).</p><p>The information that is needed to update the sliding DFT can be extracted from <code>state</code> with the following functions:</p><ul><li><a href="#FourierTools.sdft_previousdft"><code>FourierTools.sdft_previousdft</code></a> to get the DFTs of previous iterations.</li><li><a href="#FourierTools.sdft_previousdata"><code>FourierTools.sdft_previousdata</code></a> to get a previous value of the data series.</li><li><a href="#FourierTools.sdft_nextdata-Tuple{FourierTools.SDFTStateData}"><code>FourierTools.sdft_nextdata</code></a> to get the next value of the data series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierTools.sdft_windowlength" href="#FourierTools.sdft_windowlength"><code>FourierTools.sdft_windowlength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdft_windowlength(method)</code></pre><p>Return the length of the window used by <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/FourierTools.jl/blob/60de955c018389c9f22899bf3f1385eb8dee4db4/src/sdft_interface.jl#L5-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utils/">« Utility Functions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 17 February 2025 14:45">Monday 17 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
